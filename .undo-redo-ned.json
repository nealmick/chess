{
    "files": {
        "/Users/neal/dev/chess/README.md": {
            "lastCommittedState": "\n\nhttps://github.com/nealmick/chess\n\nhttps://chess-6ekpgq.fly.dev/\n\nhttps://chess-6ekpgq.fly.dev/chess/getState/\n\n\n\n\n# Chess Engine\n\nSunFish engine implemented using the Django and Chess libraries \n\n\nThere are more unique chess game states, than atoms in the known universe(10^111).  The engine evaluates any position and finds the best move.  Evaluation is done by first generating a tree structure that contains every possible board state up to a certain depth (moves ahead).  The root of the tree is the current game state.  Each branch of the tree is a possible move.  Every level of depth in the tree the player flips (MiniMax).  Terminal state of each branch is reached at the max depth or can be cut early if the branch score drops below a certain value(alpha/beta pruning).  Each branch is evaluated based on a scoring system.  The scoring system works by assigning each piece a value and adding or subtracting that value to the current branch score if the piece is captured.  Positions are also evaluated based on where each piece is located on the board, a piece map where knights are best in the center, pawns are encouraged to move forward, etcâ€¦ The best score is kept while traversing the tree and updated if a better branch score is found.  Once every move is evaluated the board is converted to a FEN string and sent back to the front end.  The engine is written in Python and is a fork of an engine called Sunfish.  All of the tree computation occurs on the server.  The server is a Django web application which receives and replies to requests from the front end.\n\n#### Django apps:\n1.  Mysite - Default django app.\n2.  chessBot - Logic for receiving board states, move generation, and returning board state.\n\n#### Install:\n\n```bash\ngit clone https://github.com/nealmick/chess\ncd chess\npip install -r requirements.txt\npython3 manage.py runserver\n```\n\n\n<img src=\"https://i.imgur.com/5g4ZcGh.png\" width=\"400\" height=\"500\" />\n\n\n\nThink you can beat it?\n# Live:\nhttps://nealmick.com/chess/\n\n# Sunfish:\nhttps://github.com/thomasahle/sunfish\n\n",
            "maxStackSize": 50,
            "redoStack": [],
            "undoStack": [
                {
                    "cursor_after": 8,
                    "cursor_before": 0,
                    "inserted": "\n\n\n\n\n\n\n\n",
                    "position": 0,
                    "removed": ""
                },
                {
                    "cursor_after": 32,
                    "cursor_before": 3,
                    "inserted": "https://chess-6ekpgq.fly.dev/",
                    "position": 3,
                    "removed": ""
                },
                {
                    "cursor_after": 34,
                    "cursor_before": 32,
                    "inserted": "\n\n",
                    "position": 37,
                    "removed": ""
                },
                {
                    "cursor_after": 78,
                    "cursor_before": 34,
                    "inserted": "https://chess-6ekpgq.fly.dev/chess/getState/",
                    "position": 34,
                    "removed": ""
                },
                {
                    "cursor_after": 35,
                    "cursor_before": 2,
                    "inserted": "https://github.com/nealmick/chess",
                    "position": 2,
                    "removed": ""
                },
                {
                    "cursor_after": 36,
                    "cursor_before": 35,
                    "inserted": "\n",
                    "position": 36,
                    "removed": ""
                }
            ]
        },
        "/Users/neal/dev/chess/chessBot/views.py": {
            "lastCommittedState": "from django.shortcuts import render\nimport pickle\nimport os\nimport json\n# Create your views here.\nfrom django.http import HttpResponse, JsonResponse\nfrom . import sunfish\n\nfrom . import tools\n\n# File to store the move history\nMOVES_FILE = os.path.join(os.path.dirname(__file__), 'moves_history.json')\n\n# Starting position FEN\nSTART_FEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\"\n\ndef parse_fen_to_board(fen):\n    \"\"\"Parse FEN string into 8x8 list.\"\"\"\n    board = []\n    position = fen.split(' ')[0]\n    rows = position.split('/')\n    for row in rows:\n        board_row = []\n        for char in row:\n            if char.isdigit():\n                board_row.extend(['.'] * int(char))\n            else:\n                board_row.append(char)\n        board.append(board_row)\n    return board\n\ndef find_move_from_boards(old_board, new_board):\n    \"\"\"Compare two board arrays and return move info with capture detection.\"\"\"\n    from_x, from_y = -1, -1\n    to_x, to_y = -1, -1\n    captured = None\n\n    for y in range(8):\n        for x in range(8):\n            old_piece = old_board[y][x]\n            new_piece = new_board[y][x]\n\n            if old_piece == new_piece:\n                continue\n\n            # Piece left this square\n            if old_piece != '.' and new_piece == '.':\n                from_x, from_y = x, 7 - y\n            # Piece arrived (or replaced another)\n            elif new_piece != '.' and old_piece != new_piece:\n                to_x, to_y = x, 7 - y\n                if old_piece != '.':\n                    captured = old_piece\n\n    if from_x >= 0 and to_x >= 0:\n        return {\n            'from': [from_x, from_y],\n            'to': [to_x, to_y],\n            'capture': captured\n        }\n    return None\n\ndef load_moves():\n    try:\n        with open(MOVES_FILE, 'r') as f:\n            return json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        return {'last_fen': START_FEN, 'moves': []}\n\ndef save_moves(data):\n    with open(MOVES_FILE, 'w') as f:\n        json.dump(data, f)\n\ndef index(request):\n    return render(request,'chessBot/index.html')\n\n\ndef getState(request):\n    \"\"\"Return the list of moves with from/to/capture info.\"\"\"\n    data = load_moves()\n    return JsonResponse({'moves': data['moves'], 'count': len(data['moves'])})\n\n\ndef resetGame(request):\n    \"\"\"Reset the game history.\"\"\"\n    save_moves({'last_fen': START_FEN, 'moves': []})\n    return JsonResponse({'status': 'reset', 'moves': []})\n\n\n\n\ndef nextMoveSunFish(request):\n    context = {}\n    \n    print('sunfish move!')\n       \n    url = request.build_absolute_uri()\n    print(url)\n\n    surl = url.split('?king=')\n    king = surl[1].split('&queen=')[0]\n\n    surl = surl[1].split('&queen=')[1]\n    \n    queen = surl.split('&rook=')[0]\n    surl = url.split('&rook=')[1]\n    rook = surl.split('&bishop=')[0]\n\n    surl = url.split('&bishop=')[1]\n    bishop = surl.split('&knight=')[0]\n\n    surl = url.split('&knight=')[1]\n    knight = surl.split('&pawn=')[0]\n\n\n    surl = url.split('&pawn=')[1]\n    pawn = surl.split('&from=')[0]\n\n\n\n\n    print(king)\n    print(queen)\n    print(rook)\n    print(bishop)\n    print(knight)\n    print(pawn)\n\n    surl = url.split('&from=')\n    _from = surl[1][0]+surl[1][1]\n    surl = url.split('&to=')\n    _to = surl[1][0]+surl[1][1]\n    \n\n    sub = url.split('&fen=')\n    subS = sub[1]\n    fen = subS.split(\"%2F\")\n    finalFen = \"\"\n    for f in fen:\n        finalFen+=f+\"/\"\n        \n    finalFen = finalFen.rstrip(finalFen[-1])\n    ff=finalFen\n    ff +=' w KQkq - 0 1'\n    fff=finalFen\n    fff +=' b KQkq - 0 1'\n\n\n\n    print('from:',_from)\n    print('to:',_to)\n    print('fen ===========', finalFen)\n\n    p = { 'P': int(pawn), 'N': int(knight), 'B': int(bishop), 'R': int(rook), 'Q': int(queen), 'K': int(king) }\n\n\n    \n    pos = tools.parseFEN(ff)\n    \n    sunfish.print_pos(pos)\n    \n    f = sunfish.getMove(pos[0],_from,_to,p)\n\n    # Load current state\n    data = load_moves()\n\n    # Parse the board to check for captures\n    board_before = parse_fen_to_board(finalFen)\n\n    # Convert chess notation (e2, e4) to x,y coordinates\n    from_x = ord(_from[0]) - ord('a')\n    from_y = int(_from[1]) - 1\n    to_x = ord(_to[0]) - ord('a')\n    to_y = int(_to[1]) - 1\n\n    # Check if player captured a piece (was there a piece at destination?)\n    dest_row = 7 - to_y  # flip for board array indexing\n    player_captured = board_before[dest_row][to_x]\n    if player_captured == '.':\n        player_captured = None\n\n    # Record player's move\n    player_move = {\n        'from': [from_x, from_y],\n        'to': [to_x, to_y],\n        'capture': player_captured\n    }\n    data['moves'].append(player_move)\n\n    # Build intermediate board (after player move, before AI)\n    # Apply player's move to get intermediate state\n    board_after_player = [row[:] for row in board_before]  # copy\n    piece_moved = board_after_player[7 - from_y][from_x]\n    board_after_player[7 - from_y][from_x] = '.'\n    board_after_player[7 - to_y][to_x] = piece_moved\n\n    # Now find AI's move by comparing intermediate to final\n    ai_move = find_move_from_boards(board_after_player, parse_fen_to_board(f))\n    if ai_move:\n        data['moves'].append(ai_move)\n\n    save_moves(data)\n\n    return JsonResponse({'asdf': f})\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "maxStackSize": 50,
            "redoStack": [],
            "undoStack": [
                {
                    "cursor_after": 390,
                    "cursor_before": 359,
                    "inserted": "import json\n# Create your views here.\nfrom django.http import HttpResponse, JsonResponse\nfrom . import sunfish\n\nfrom . import tools\n\n# File to store the move history\nMOVES_FILE = os.path.join(os.path.dirname(__file__), 'moves_history.json')\n\n# Starting position FEN\nSTART_FEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\"\n\ndef \nparse_fen_to_board(fen):\n    \"\"\"Parse FEN string into 8x8 list.\"\"\"\n    board = []\n    position = fen.split(' ')[0]\n    rows = position.split('/')\n    for row in rows:\n        board_row = []\n        for char in row:\n            if char.isdigit():\n                board_row.extend(['.'] * int(char))\n            else:\n                board_row.append(char)\n        board.append(board_row)\n    return board\n\ndef find_move_from_boards(old_board, new_board):\n    \"\"\"Compare two board arrays and return move info with capture detection.\"\"\"\n    from_x, from_y = -1, -1\n    to_x, to_y = -1, -1\n    captured = None\n\n    for y in range(8):\n        for x in range(8):\n            old_piece = old_board[y][x]\n            new_piece = new_board[y][x]\n\n            if old_piece == new_piece:\n                continue\n\n            # Piece left this square\n            if old_piece != '.' and new_piece == '.':\n                from_x, from_y = x, 7 - y\n            # Piece arrived (or replaced another)\n            elif new_piece != '.' and old_piece != new_piece:\n                to_x, to_y = x, 7 - y\n                if old_piece != '.':\n                    captured = old_piece\n\n    if from_x >= 0 and to_x >= 0:\n        return {\n            'from': [from_x, from_y],\n            'to': [to_x, to_y],\n            'capture': captured\n        }\n    return None\n\ndef load_moves():\n    try:\n        with open(MOVES_FILE, 'r') as f:\n            return json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        return {'last_fen': START_FEN, 'moves': []}\n\ndef save_moves(data):\n    with open(MOVES_FILE, 'w') as f:\n        json.dump(data, f)\n\ndef index(request):\n    return render(request,'chessBot/index.html')\n\n\ndef getState(request):\n    \"\"\"Return the list of moves with from/to/capture info.\"\"\"\n    data = load_moves()\n    return JsonResponse({'moves': data['moves'], 'count': len(data['moves'])})\n\n\ndef resetGame(request):\n    \"\"\"Reset the game history.\"\"\"\n    save_moves({'last_fen': START_FEN, 'moves': []})\n    return JsonResponse({'status': 'reset', 'moves': []})\n\n\n\n\ndef nextMoveSunFish(request):\n    context = {}\n    \n    print('sunfish move!')\n       \n    url = request.build_absolute_uri()\n    print(url)\n\n    surl = url.split('?king=')\n    king = surl[1].split('&queen=')[0]\n\n    surl = surl[1].split('&queen=')[1]\n    \n    queen = surl.split('&rook=')[0]\n    surl = url.split('&rook=')[1]\n    rook = surl.split('&bishop=')[0]\n\n    surl = url.split('&bishop=')[1]\n    bishop = surl.split('&knight=')[0]\n\n    surl = url.split('&knight=')[1]\n    knight = surl.split('&pawn=')[0]\n\n\n    surl = url.split('&pawn=')[1]\n    pawn = surl.split('&from=')[0]\n\n\n\n\n    print(king)\n    print(queen)\n    print(rook)\n    print(bishop)\n    print(knight)\n    print(pawn)\n\n    surl = url.split('&from=')\n    _from = surl[1][0]+surl[1][1]\n    surl = url.split('&to=')\n    _to = surl[1][0]+surl[1][1]\n    \n\n    sub = url.split('&fen=')\n    subS = sub[1]\n    fen = subS.split(\"%2F\")\n    finalFen = \"\"\n    for f in fen:\n        finalFen+=f+\"/\"\n        \n    finalFen = finalFen.rstrip(finalFen[-1])\n    ff=finalFen\n    ff +=' w KQkq - 0 1'\n    fff=finalFen\n    fff +=' b KQkq - 0 1'\n\n\n\n    print('from:',_from)\n    print('to:',_to)\n    print('fen ===========', finalFen)\n\n    p = { 'P': int(pawn), 'N': int(knight), 'B': int(bishop), 'R': int(rook), 'Q': int(queen), 'K': int(king) }\n\n\n    \n    pos = tools.parseFEN(ff)\n    \n    sunfish.print_pos(pos)\n    \n    f = sunfish.getMove(pos[0],_from,_to,p)\n\n    # Load current state\n    data = load_moves()\n\n    # Parse the board to check for captures\n    board_before = parse_fen_to_board(finalFen)\n\n    # Convert chess notation (e2, e4) to x,y coordinates\n    from_x = ord(_from[0]) - ord('a')\n    from_y = int(_from[1]) - 1\n    to_x = ord(_to[0]) - ord('a')\n    to_y = int(_to[1]) - 1\n\n    # Check if player captured a piece (was there a piece at destination?)\n    dest_row = 7 - to_y  # flip for board array indexing\n    player_captured = board_before[dest_row][to_x]\n    if player_captured == '.':\n        player_captured = None\n\n    # Record player's move\n    player_move = {\n        'from': [from_x, from_y],\n        'to': [to_x, to_y],\n        'capture': player_captured\n    }\n    data['moves'].append(player_move)\n\n    # Build intermediate board (after player move, before AI)\n    # Apply player's move to get intermediate state\n    board_after_player = [row[:] for row in board_before]  # copy\n    piece_moved = board_after_player[7 - from_y][from_x]\n    board_after_player[7 - from_y][from_x] = '.'\n    board_after_player[7 - to_y][to_x] = piece_moved\n\n    # Now find AI's move by comparing intermediate to final\n    ai_move = find_move_from_boards(board_after_player, parse_fen_to_board(f))\n    if ai_move:\n        data['moves'].append(ai_move)\n\n    save_moves(data",
                    "position": 60,
                    "removed": "# Create your views here.\nfrom django.http import HttpResponse, JsonResponse\nfrom . import sunfish\n\nfrom . import tools\n\n# File to store the latest FEN\nFEN_STATE_FILE = os.path.join(os.path.dirname(__file__), 'latest_fen.txt')\n\ndef index(request):\n    return render(request,'chessBot/index.html')\n\n\ndef getState(request):\n    \"\"\"Return the latest FEN string from the last game move.\"\"\"\n    try:\n        with open(FEN_STATE_FILE, 'r') as f:\n            fen = f.read().strip()\n        return JsonResponse({'fen': fen})\n    except FileNotFoundError:\n        return JsonResponse({'fen': None, 'error': 'No game state yet'})\n\n\n\n\ndef nextMoveSunFish(request):\n    context = {}\n    \n    print('sunfish move!')\n       \n    url = request.build_absolute_uri()\n    print(url)\n\n    surl = url.split('?king=')\n    king = surl[1].split('&queen=')[0]\n\n    surl = surl[1].split('&queen=')[1]\n    \n    queen = surl.split('&rook=')[0]\n    surl = url.split('&rook=')[1]\n    rook = surl.split('&bishop=')[0]\n\n    surl = url.split('&bishop=')[1]\n    bishop = surl.split('&knight=')[0]\n\n    surl = url.split('&knight=')[1]\n    knight = surl.split('&pawn=')[0]\n\n\n    surl = url.split('&pawn=')[1]\n    pawn = surl.split('&from=')[0]\n\n\n\n\n    print(king)\n    print(queen)\n    print(rook)\n    print(bishop)\n    print(knight)\n    print(pawn)\n\n    surl = url.split('&from=')\n    _from = surl[1][0]+surl[1][1]\n    surl = url.split('&to=')\n    _to = surl[1][0]+surl[1][1]\n    \n\n    sub = url.split('&fen=')\n    subS = sub[1]\n    fen = subS.split(\"%2F\")\n    finalFen = \"\"\n    for f in fen:\n        finalFen+=f+\"/\"\n        \n    finalFen = finalFen.rstrip(finalFen[-1])\n    ff=finalFen\n    ff +=' w KQkq - 0 1'\n    fff=finalFen\n    fff +=' b KQkq - 0 1'\n\n\n\n    print('from:',_from)\n    print('to:',_to)\n    print('fen ===========', finalFen)\n\n    p = { 'P': int(pawn), 'N': int(knight), 'B': int(bishop), 'R': int(rook), 'Q': int(queen), 'K': int(king) }\n\n\n    \n    pos = tools.parseFEN(ff)\n    \n    sunfish.print_pos(pos)\n    \n    f = sunfish.getMove(pos[0],_from,_to,p)\n\n    # Save the latest FEN state\n    with open(FEN_STATE_FILE, 'w') as file:\n        file.write(f"
                },
                {
                    "cursor_after": 389,
                    "cursor_before": 359,
                    "inserted": "",
                    "position": 389,
                    "removed": "\n"
                }
            ]
        }
    }
}